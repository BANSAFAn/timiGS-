/// Database service using Rust backend via flutter_rust_bridge
///
/// This service acts as a bridge between Flutter UI and Rust database operations.
/// All actual database operations are performed in Rust for better performance.

import 'package:path_provider/path_provider.dart';
import 'dart:io';
import '../models/activity_session.dart';
import '../models/app_usage_summary.dart';
import '../models/daily_stats.dart';
import '../models/settings.dart';

// Import generated Rust bindings (will be generated by flutter_rust_bridge_codegen)
// import '../src/rust/api.dart' as rust_api;

class DatabaseService {
  static final DatabaseService instance = DatabaseService._init();
  bool _initialized = false;

  DatabaseService._init();

  /// Initialize the database
  ///
  /// This must be called once at app startup before any database operations.
  Future<void> initialize() async {
    if (_initialized) return;

    final Directory appDocDir = await getApplicationDocumentsDirectory();
    final String dbPath = '${appDocDir.path}/activity.db';

    // TODO: Uncomment when flutter_rust_bridge bindings are generated
    // rust_api.initDatabase(path: dbPath);

    _initialized = true;
    print('DatabaseService initialized with Rust backend at: $dbPath');
  }

  /// Ensure database is initialized
  void _ensureInitialized() {
    if (!_initialized) {
      throw StateError(
          'DatabaseService not initialized. Call initialize() first.');
    }
  }

  // ============ Activity Sessions ============

  /// Start a new activity tracking session
  Future<int> startSession({
    required String appName,
    required String windowTitle,
    required String exePath,
  }) async {
    _ensureInitialized();

    // TODO: Replace with Rust call when bindings are generated
    // final result = await rust_api.startSession(
    //   session: rust_api.NewSession(
    //     appName: appName,
    //     windowTitle: windowTitle,
    //     exePath: exePath,
    //   ),
    // );
    // return result;

    // Temporary placeholder
    return DateTime.now().millisecondsSinceEpoch;
  }

  /// End an activity session
  Future<void> endSession(int id) async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // await rust_api.endSession(sessionId: id);
  }

  /// Get sessions for today
  Future<List<ActivitySession>> getTodaySessions() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // final sessions = await rust_api.getTodaySessions();
    // return sessions.map((s) => ActivitySession.fromRust(s)).toList();

    return [];
  }

  /// Get sessions for a specific date
  Future<List<ActivitySession>> getSessionsForDate(DateTime date) async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // final sessions = await rust_api.getSessionsForDate(
    //   year: date.year,
    //   month: date.month,
    //   day: date.day,
    // );
    // return sessions.map((s) => ActivitySession.fromRust(s)).toList();

    return [];
  }

  // ============ Analytics ============

  /// Get usage summary for today
  Future<List<AppUsageSummary>> getTodaySummary() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // final summaries = await rust_api.getTodaySummary();
    // return summaries.map((s) => AppUsageSummary.fromRust(s)).toList();

    return [];
  }

  /// Get weekly statistics
  Future<List<DailyStats>> getWeeklyStats() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // final stats = await rust_api.getWeeklyStats();
    // return stats.map((s) => DailyStats.fromRust(s)).toList();

    return [];
  }

  /// Get total tracked time for today in seconds
  Future<int> getTotalTimeToday() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // return await rust_api.getTotalTimeToday();

    return 0;
  }

  // ============ Settings ============

  /// Get all settings
  Future<AppSettings> getSettings() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // final settings = await rust_api.getSettings();
    // return AppSettings.fromRust(settings);

    return AppSettings();
  }

  /// Save all settings
  Future<void> saveSettings(AppSettings settings) async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // await rust_api.saveSettings(settings: settings.toRust());
  }

  /// Get a single setting value
  Future<String?> getSetting(String key) async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // return await rust_api.getSetting(key: key);

    return null;
  }

  /// Save a single setting
  Future<void> saveSetting(String key, String value) async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // await rust_api.saveSetting(key: key, value: value);
  }

  // ============ Utilities ============

  /// Export database path for backup
  Future<String> exportDatabase() async {
    _ensureInitialized();

    // TODO: Replace with Rust call
    // return rust_api.getDatabasePath() ?? '';

    final Directory appDocDir = await getApplicationDocumentsDirectory();
    return '${appDocDir.path}/activity.db';
  }

  /// Close database connection
  Future<void> close() async {
    if (!_initialized) return;

    // TODO: Replace with Rust call
    // rust_api.closeDatabase();

    _initialized = false;
  }
}
